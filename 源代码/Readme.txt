上次在网站上上传的作业还没完全调试完，报告也没写。
现在基本已经排除了问题，做了如下改进:
服务器端发送消息的长度计算采用buff的strlen()+1，而不是用sizeof()。
做这个改进有如下好处：
	sizeof会把整个buff都发出去，对于PC端没什么问题，但是在手机端却是很费流量的。
	以前要设置相同的发送buff和接收buff大小，都是2048，由于手机的网络不好，很容易丢包。
	（以前的协议为 [type]\n[form]\n[to]\n[data]   到2048个字节算一个完整的消息)

由于这个改进，协议变为：
[type]\n[form]\n[to]\n[data]\0
type   代表消息的类型；
from   代表发送者的用户名；
to        代表接收者的用户名；
data    代表发送的内容；
\0	    作为一个消息的结束。
	注： 由于发送buff字符串是用GBK编码方式，而发送的时候的长度是strlen(buff)+1 ，这样是发送1个字符的\0。
		
由于这个改进，客户端也改了计算接收到一个消息的算法；
用sizeof的时候，是接到2048个字节算一个完整的消息。改进之后先分析buff的字节流，读到\0算一个完整的消息。

算法改进之后就算放在真实的网络里，手机客户端不会再丢包，流量也小很多。

其他改进：
	修改服务器存贮用户名的字符串长度，从20变为100；
	修改客户端限制 输入用户名的长度，限制为都是18个字节。
	未改进前 用户名输个18个字节以上的字符串用户名，服务器缓冲区溢出，导致崩溃。

	手机客户端，修改布局文件，能适应各种分辨率的屏幕。以前只能在ME525的分辨率上正常显示。
	改正手机客户端不能正常退出，按返回键时会提示程序崩溃。以前复写Activity OnStop方法时忘记调用父类的Onstop。
PC客户端要求 NET FRAMEWORK 2.0 以上。

最近改进：
	改进服务器接收的字符串的sscanf表达式，以前不能接收带有空格的信息。用正则表达式解决
	如sscanf(indata , "%s" , outdata)  ,如果indata里带有空格，那么outdata就是它带空格前的字符串。
	sscanf(receive_buff  , "%d\n%[^\n]\n%[^\n]\n%[^\0]", &type , fromuser , touser , data);
	这样会严格按照协议的格式读取，可以接收带空格或者回车的信息。